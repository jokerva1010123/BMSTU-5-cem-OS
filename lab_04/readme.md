# Задание: Создать программу демона
```
Сборка
    gcc main.c -o app.exe
Запустить демона без прав суперюзера:
    ./app.exe
Запустить демона с правами суперюзера:
    sudo ./app.exe
Найти демона в списке процессов (запомнить pid):
    ps -axj
Посмотреть log:
    tail -n 100 /var/log/syslog
    sudo dmesg -F "var/log/syslog" | grep app.exe
Посмотреть номера сигналов:
    kill -l
Отправить SIGHUP:
    sudo kill -1 %pid%
Отправить SIGTERM:
    sudo kill -15 %pid%
```

# Вопросы
## Вопросы по ps -axj
Флаги для вывода:
- a - процессы, которыми владеют другие пользователи;
- x - процессы, которые не имеют управляющего терминала (TTY);
- j - вывод дополнительных сведений о процессах.

Идентификаторы:
- PPID - идентификатор процесса-родителя **(терминальный процесс, поскольку после вызова fork() завершился родительский процесс, и потомок был "усыновлен" терминальным процессом)**;
- PID (process id) = PGID (process group) = SID (session id);
- TTY - имя терминала;
- TPGID - идентификатор группы процессов терминала, к которому подключен процесс (-1) если нет терминала;
- STAT - состояние процесса;
    Состояния:
    - S - interruptable sleep;
    - D - uninterruptable sleep (ожидание завершения устройства I/O);
    - I - работа в режиме ядра.
    Доп:
    - s - лидер сессии;
    - l - многопоточный.
 - TIME - время работы процесса;
 - COMMAND - название команды, запустившей процесс (вроде).
 
У демона PID = PGID = SID, т.к. у него не должно быть управляющего терминала, и он не должен получать сигналов от процессов из своей группы/сессии.

## Очень важно

**Происходит вызов fork(), создается процесс-потомок, завершается предок. В результате этого действия потомок теряет группу (процессы, вызывающие fork() становятсся лидерами группы). Таким образом, процесс-потомок не является лидером группы, что является обязательным условием вызова setsid(). В результате всего этого демон утрачивает управляющий терминал и становится лидером группы и сессии.**

## В какой точке программы процесс становится демоном?
Указать на _вызов_ функции daemonize()
 
## Что делает already_running()?
Для обеспечения работы демона в единственном экземпляре. Осуществляется блокировкой файла в области ядра ОС, пока один процесс "держит" блокировку, другой заблокировать файл не сможет

## Почему демон должен работать в единственном экземпляре?
Демон предоставляет сервис. Не нужно предоставлять одни и те же услуги.

## Порядок действий в daemonize.
По проге и по конспекту семинара :(

## Почему нужно запускать с правами суперпользователя?
Демона нужно запускать с правами суперпользователя, чтобы можно было создать файл в области ядра ОС для обеспечения работы демона в единственном экземпляре.

## Объяснить назначение аргументов, передающихся функции блокировки файла.
У меня используется flock, первый аргумент - дескриптор открытого файла, второй - флаги (LOCK_EX - эксклюзивная блокировка, LOCK_NB - процесс не будет блокироваться в ожидании разблокировки файла, если он уже заблокирован, ака _неблокирующий запрос_). 

Терминал 
показать, что он работает:

`ps -ajx`

узнать id из файла блокировки:

`cat /var/run/daemon.pid`

посмотреть лог:

`sudo cat /var/log/syslog | grep dasha_deamon` (за такое название демона хихикали)

вызывать SIGHUB:

`sudo kill -1 PID`

вызывать SIGTERM:

`sudo kill -15 PID` 

убить демона:

`sudo kill -9 PID`


Вопросы:
-- 

- что делает твой демон?

  с периодичностью в SLEEP_TIME пишет в лог файл дату и время

- в какой момент процесс становится демоном?

  показать на вызов функции daemonize() в мейне

- зачем делать umask? где делать umask?

  чтобы сбросить маску режима создания файлов, вызывается в предке. таким образом процесс может создавать файлы с любыми правами доступа

- пояснить за каждую колоночку

  | PPID | PID | PGID | SID | TTY | TPGID | STAT |
  |------|-----|------|-----|------|------|------|
  | 2059 | 19893 | 19893 |   19893 | ? | -1 | Ssl | 

  - почему PPID такой? почему его усынловляет 2059? 

    потому что демона запускаем сами из терминала и его усыновляет процесс -- потомок процесса с идентификатором 1

  - PID == PGID == SID ?
  
    демон является лидером группы и лидером сессии, а вообще он там единственный, но это мы говорим для себя!

  - TTY == ? 
  
    нет управляющего терминала

  - TPGID == -1 
  
    отсутсвует терминальная группа (т.к. нет управляющего терминала)

  - “S” - ожидание завершения события (interruptable sleep). 
  
    прерываемый сон (S) -- в состоянии ожидания завершения *события* (прерывать можем с помощью сигналов)
  
    непрерываемый сон (D) -- в состоянии ожидания завершения *процесса ввода-вывода*

  - “s” - лидер сессии
  - “l” - многопоточость
  
- что творится в функции lockfile?
   
  ```
  заполняем поля структуры flock
  struct flock fl;
   
  fl.l_type = F_WRLCK; - блокируем разделение на запись
  
  следующие строчки - блокировка всего файла от начала до конца
  
  fl.l_start = 0;
  fl.l_whence = SEEK_SET;
  fl.l_len = 0;
  
  передаем в fctln, то есть применяем конфигурацию блокировки к дескриптору

  return fcntl(fd, F_SETLK, &fl);
  ```
  

- для чего функция already_running?
  
  чтобы сохранить демона в единственной экземпляре

- с помощью какого механизма мы это реализуем?

  с помощью механизма блокировки файла, куда демон пишет свой id
  
  
- fd0, fd1, fd2 - что за файлы? 

  stdin, stdout, stderr


Замечания к Раго:
--

- форк надо проверять на -1

- sigaction на SIGHUP сделать ДО setsid